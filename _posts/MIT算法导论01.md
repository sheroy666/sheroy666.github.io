## 分析算法--理论基础
- 本门课最在乎的是性能，程序设计中 用户友好、时间成本、可扩展性等比性能更重要
- 性能决定算法是否可行，基本标准

***运行时间（running time）的影响因素：***
- 输入：输入本就升序，就不需要做什么；降序则需要不断调整位置
- 输入的规模：输入的数组越大，运行越慢；将输入的大小参数化，把运行时间看作是输入大小的函数

- 运行时间的最大值----保证对用户的承诺

***分析的种类：***
- 最坏情况分析（最常用）：T（n）---输入规模为n时的最长运行时间---表示相关性但不是函数---因为输入同为n时，时间随输入的好坏决定---输入规模与最长运行时间可以构成函数，因为最长运行时间只有一个结果
- 平均情况分析（有时用）：T（n）---输入规模为n时所有可能的运行时间的期望----每种输入的运行时间*那种输入出现的概率-----为了计算概率，需要进行假设：均匀分布（每种出现概率相同）、随机的概率分布（可能不成立）
- 最好情况分析（bogus假象）：最好的输入进来可以得到，但对算法没意义

- 在同一台机器上对算法进行比较，不同机器计算能力不同---relative speed
- 绝对速度：在所有机器上都很快

***渐进分析：***
- 忽略掉那些依赖于机器的常量
- 不关注实际的运行时间，而是关注运行时间的增长
- 忽略公式的低阶项以及前面的常数因子----theta符号
- 当n趋于∞时，theta（n的平方）一定快于theta（n的立方）----在某一个交点后，theta（n的平方）一直小于theta（n的立方）
- 渐进分析使得不同计算机上的常量因子，不会影响运行时间---规模很大时，影响不大
- 交点有时太大了，导致在这个规模以后，计算机已经无法运行，所以这个规模以前theta（n的立方）快于theta（n的平方）---需要综合分析


## 排序算法---sorting

- 举例： 对一组数字重新排序后，进行输出：输出时为升序排列
- 插入排序：Insertion sort---对数组A进行排序---从第二个元素到第n个元素进行遍历：每个元素j拿出来（key）与前一个元素（前面元素中最大的元素）进行比较，如果前一个元素更大，则循环对前面所有元素进行比较，若前一个更大则互换位置。找到合适的位置进行插入，之后前j个为已排序部分（下标从1到n）
- 插入排序的最坏情况：降序排列的数组---最长运行时间：j从2到n对theta(j)求和--算术级数可得结果为theta(n的平方)----不要轻易进行运算，属于描述符号
- 假设每一个原子操作占用某常数时间，内存引用次数---访问这个变量内存的次数
- 对于n较小时，速度还可以。但是n较大时变慢

- 归并排序：merge sort---如果元素只有一个，则不需排序。否则递归地对A[1...n/2(向上取整)]和A[n/2(向上取整)+1.....n]排序，之后进行两个子序列的归并
- 归并：从两个排好序的数组中拿到对首两个元素，谁小拿出来，接着对比对首，直到所有数据拿出来排好---耗费时间theta(n)---线性时间
- theta(1)代表常数
- 递归排序---递归树：归并n的数组时需要先在叶节点有两个排好序的数组---每个数组时间为T(n/2)---再往下分解--

- n/（2的x次幂）=1所以可得x=log(n)--以2为底所以递归树的高度为lg(n)
- 最后一排叶节点数目为n----n*theta(1) = theta(n)
- cn*lg(n)+theta(n)=T(n)总的时间---前一项比后一项高阶所以---T(n)=theta(n*lg(n))-----输入规模充分大（n>30）的时候归并排序比插入排序快

















